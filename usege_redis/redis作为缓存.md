## **`Read/Write Through`**
1. 在查询数据的时候, 先去缓存中查询, 如果命中缓存就直接返回数据
2. 如果没有没有命中, 就去数据库中查询, 得到查询结果后把数据写入缓存, 再返回
3. 更新数据的时候, 先更新数据库中的数据, 如果更新成功再去更新缓存中的数据

### Read/Write Through, 在并发的情况下有一定概率会出现"脏数据"问题 —— 缓存中的数据可能会被错误的更新成了旧数据
* 对于同一份数据, 同时产生了一个读请求和一个写请求, 这两个请求被分配到两个不同的线程并行执行, 读线程尝试读缓存没命中, 去数据库读到了订单数据. 在处理写请求的线程中, 先后更新了数据和缓存, 然后拿着旧数据的读线程又把缓存更新成了旧数据
* 还有一种情况是两个线程对同一份数据并发写, 也有可能造成缓存中的"脏数据". 类似ABA问题, Read/Write Through缓存策略出现"脏数据"的概率是和系统的数据量以及并发数量正相关, 当系统的数据量最够大并且并发足够多的情况下, 这种脏数据几乎是必然出现的