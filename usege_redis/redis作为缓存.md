## **`Read/Write Through`**  [[read_write_through.py](./read_write_through.py)]
1. 在查询数据的时候, 先去缓存中查询, 如果命中缓存就直接返回数据
2. 如果没有没有命中, 就去数据库中查询, 得到查询结果后把数据写入缓存, 再返回
3. 更新数据的时候, 先更新数据库中的数据, 如果更新成功再去更新缓存中的数据

### Read/Write Through, 在并发的情况下有一定概率会出现"脏数据"问题 —— 缓存中的数据可能会被错误的更新成了旧数据
* 对于同一份数据, 同时产生了一个读请求和一个写请求, 这两个请求被分配到两个不同的线程并行执行, 读线程尝试读缓存没命中, 去数据库读到了订单数据. 在处理写请求的线程中, 先后更新了数据和缓存, 然后拿着旧数据的读线程又把缓存更新成了旧数据
* 还有一种情况是两个线程对同一份数据并发写, 也有可能造成缓存中的"脏数据". 类似ABA问题, Read/Write Through缓存策略出现"脏数据"的概率是和系统的数据量以及并发数量正相关, 当系统的数据量最够大并且并发足够多的情况下, 这种脏数据几乎是必然出现的

## **`Cache Aside`**  
1. Cache Aside模式在大多数情况下是使用缓存的最佳方式
2. Cache Aside 与 Read/Write Through模式非常像, 它们在处理读请求的逻辑是完全一样的. 唯一的一个小差别是Cache Aside模式在更新数据的时候, 并不尝试去更新缓存, 而是去删除缓存
3. 服务在收到更新数请求之后, 先更新数据库, 如果更新了就尝试去删除缓存中的这份数据. 如果缓存中存在这份数据就删除, 否则不做任何操作, 然后返回更新成功. 这个更新后的数据将在下次被访问的时候加载到缓存中. 使用Cache Aside模式来更新缓存可以非常有效的规避并发读写导致的脏数据问题

### Cache Aside, 在某些情况下还是会有一定概率出现"脏数据"问题, 但是概率比 Read/Write Through 小很多
* 对于同一份数据, 读线程读取缓存未命中, 查询当前数据库数据. 写线程更新当前数据库数据, 删除缓存(此时缓存不存在). 读线程将老数据更新至缓存, 导致当前数据库数据与缓存不一致