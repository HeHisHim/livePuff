### [一文说尽MySQL事务及ACID特性的实现原理](https://zhuanlan.zhihu.com/p/56874694)

## **`MySQL事务基础概念`**
### 基础概念
1. 事务(Transaction)是访问和更新数据库的程序执行单元(不可分割单元).
2. 一个事务中可能包含一个或多个SQL语句, 这些语句要么全部都执行, 要么全部都不执行

## **`MySQL的逻辑架构和存储引擎`**
* 第一层: 处理客户端请求连接, 授权认证等
* 第二层: 服务器层, 负责查询语句的解析, 优化, 缓存以及内置函数的实现, 存储过程等
* 第三层: 存储引擎, 负责MySQL中数据的存储和提取. MySQL中服务器层不管理事务, 事物由存储引擎实现

* MySQL支持事务的引擎有InnoDB, NDB Cluster等. 其中InnoDB用的最为广泛, 其他存储引擎(MyIsam, Memory)不支持事务

## **`提交和回滚`**
### 典型事务操作格式如下
1. `start transaction;` 或者 `begin;`  -- 标志事务的开始
2. `...` 一条或多条SQL语句
3. `commit;`  -- 提交事务, 将执行结果写入数据库

* 如果SQL语句执行出现问题, 会调用rollback, 回滚所有已经执行成功的SQL语句. 也可以直接在事务中执行rollback

## **`自动提交`**
* MySQL默认采用的是自动提交模式, 可以使用`show variables like "autocommit";`查看
在自动提交模式中, 如果没有`start transaction;`或`begin`显示开始一个事务, 则每个SQL语句都被当成一个事务执行提交操作

* 通过`set autocommit = 0`可以关闭autocommit. autocommit是针对连接的, 在一个连接中修改了参数, 不会影响别的连接

* 如果关闭了autocommit, 则所有SQL语句都在一个事务中, 直到执行了`commit`或者`rollback`. 表明该事务已经结束, 同时开始新事务

## **`提交时的特殊操作`**
* 如果遇到一些特殊命令(create table / drop table / alter table / lock table等), 则会马上强制执行commit
* 不过常用的select, insert, update和delete命令, 不会强制执行事务

## **`事务的ACID特性`**
* ACID是衡量事务的四个特性
1. 原子性(A: atomicity, 或称不可分割性)
2. 一致性(C: consistency)
3. 隔离性(I: isolation)
4. 持久性(D: durability)

* 按照严格标准, 只有同时满足ACID 4个特性才能称为事务. 但是MySQL或Oracle都未能满足

## **`事务的ACID实现原理`**
## **`原子性`**
* 原子性 -- 一个事务是一个不可分割的单位, 其中的操作要么都做, 要么都不做
* 实现原理: undo log
    ## **`MySQL日志`**
    * MySQL的日志有很多种: 二进制日志(binlog), 错误日志, 查询日志, 慢查询日志等
    * InnoDB存储引擎还提供了两种事务日志: redo log(重做日志) -- 用于保证事务的持久性, undo log(回滚日志) -- 用于保证事务的原子性和隔离性

    ## **`undo log`**
    * 实现原子性的关键, 当事务回滚时能够撤销所有已经成功执行的SQL语句. InnoDB实现的回滚, 依靠的就是undo log
    * 当事务对数据库进行修改时, InnoDB会生成对应的undo log
    * 如果事务执行失败或者调用了rollback, 导致事务需要回滚, 便可以利用undo log中的信息将数据回滚到数据修改之前

    ## **`根据undo log回滚`**
    * undo log属于逻辑日志, 记录的是SQL执行的相关信息. 回滚过程InnoDB会根据undo log的内容做与之前相反的工作
    1. 对于每个INSERT, 回滚会执行DELETE
    2. 对于每个DELETE, 回滚会执行INSERT
    3. 对于每个UPDATE, 回滚会执行一个相反的UPDATE, 将数据改回去
    * 以UPDATE为例, 当事务执行了UPDATE时, 其生成的undo log中会包含修改的主键, 修改的列, 这些列在修改前后的值. 回滚时便可以根据这些信息将数据还原到UPDATE之前的状态

## **`持久性`**
* 事务一旦提交, 它对数据库的修改就应该是永久性的. 接下来的其他操作或者故障不应该对其有任何影响
* 实现原理: redo log -- 使用redo log的原因是因为InnoDB作为MySQL的存储引擎, 数据是放在磁盘中的, 但如果每次读写都需要磁盘IO, 则效率会很低, 所以InnoDB提供了缓存(Buffer Pool)

    ## **`Buffer Pool`**
    * Buffer Pool包含了磁盘中部分数据页的映射, 作为访问数据库的缓冲
    1. 当从数据库读取数据时, 会首先从Buffer Pool中读取, 如果Buffer Pool没有, 则从磁盘中读取后放入Buffer Pool
    2. 当向数据库写入数据时, 会首先写入Buffer Pool, Buffer Pool 中修改的数据会定期刷新到磁盘中(这一过程称为刷脏)
    * Buffer Pool的使用大大提高了读写数据的效率, 但是也带来了新的问题. 如果MySQL宕机, 而此时Buffer Pool中修改的数据还未刷脏, 就会导致数据的丢失. 事务的持久性无法保证

    ## **`redo log`**
    * redo log被引入来解决MySQL宕机缓存数据丢失问题: 当数据修改时, 除了将数据写入Buffer Pool, 还会在redo log记录这次数据. 当事务提交时, fsync接口会对redo log刷盘
    * 如果MySQL宕机, 重启时可以读取redo log中的数据, 对数据库进行恢复
    * redo log采用的是WAL(Write-ahead logging, 预写式日志). 所有修改先写入日志, 再更新到Buffer Pool, 保证了数据不会因为MySQL宕机而丢失, 满足了持久性要求

    ## **`redo log的执行为什么比刷脏要快`**
    1. 刷脏是随机IO, 因为每次修改的数据位置随机, 但是redo log是追加操作, 属于顺序IO
    2. 刷脏是以数据页(Page)为单位的, MySQL默认页大小是16KB, 一个Page上一个小修改都要整页写入. 而redo log只包含真正需要写入的部分, 无效IO大大减少
    ## **`redo log和binlog`**
    * MySQL中的binlog也可以记录写操作并用于数据恢复, 但是两者有着根本性的区别
    1. 作用不同
        * redo log主要用于crash-recovery(崩溃恢复), 保证MySQL宕机也不会丢失数据
        * binlog主要用于point-in-time recovery(时间点恢复), 保证服务器可以基于时间点恢复数据, 此外binlog还用于主从复制
    2. 层次不同
        * redo log是InnoDB存储引擎实现的
        * 而binlog是MySQL的服务器层实现的, 同时支持InnoDB和其他存储引擎
    3. 内容不同
        * redo log是物理日志, 内容是基于磁盘的Page
        * binlog是逻辑日志, 内容是一条条SQL语句
    4. 写入时机不同
        * redo log写入时机相对多元. 默认情况下, 当事务提交时会调用fsync对redo log进行刷盘. 修改`innodb_flush_log_at_trx_commit`参数可以改变该策略, 但事务的持久性无法保证
        * redo log除了事务提交时, 还有其他刷盘时机: 如master thread每秒刷盘一次redo log等, 这样的好处是不一定要等到commit时刷盘, commit速度大大加快
        * binlog只在事务提交的时候写入

## **`隔离性`**
* 与原子性, 持久性侧重于研究事物本身不同, 隔离性研究的是不同事务之间的相互影响. 隔离性是指事务内部的操作与其他事务是隔离的, 并发执行的各个事务之间不能相互干扰
* 严格的隔离性, 对应了事务隔离级别中的Serializable(可串行化), 但实际应用中处于性能方面的考虑很少会使用可串行化
* 隔离性的讨论分为以下两方面
1. A事务写操作对B事务写操作的影响: 锁机制保证隔离性
2. A事务写操作对B事务读操作的影响: MVCC保证隔离性

    ## **`锁机制`**
    * 两个事务的写操作之间的相互影响, 隔离性要求同一时刻只能有一个事务对数据进行写操作. InnoDB通过锁机制来保证这一点
    * 锁机制原理
        1. 事务在修改数据之前, 需要先获得相应的锁
        2. 获得锁之后, 事务便可以修改数据
        3. 该事务操作期间, 这部分数据是锁定的. 其他事务如果需要修改这部分数据, 需要等待当前事务提交或回滚后释放锁
    * 行锁与表锁
        * 按照粒度, 锁可以分为表锁, 行锁以及其他位于二者之间的锁
        1. 表锁在操作数据时会锁定整张表, 并发性能较差
        2. 行锁则只锁定需要操作的数据, 并发性能好
        3. 但是由于加锁本身需要消耗资源(获得锁, 检查锁, 释放锁等都需要消耗资源), 因此在锁定数据较多的情况下使用表锁可以节省大量资源
        4. MySQL中不同存储引擎支持的锁是不一样的, 例如Mylsam只支持表锁, 而InnoDB同时支持表锁和行锁. 出于性能考虑, 绝大多数情况下使用的都是行锁
    * 查看锁信息
        * `select * from information_schema.innodb_locks;` 锁的概况
        * `show engine innodb status;` InnoDB整体状态, 其中包括锁的情况

        * 比如在A事务中执行: `begin;`
        `Update account Set balance = 1000 where id = 1;`
        在B事务中执行: 
        `begin;`
        `Update account Set balance = 2000 where id = 1;`
        此时可通过上述命令查看锁情况

    ## **`脏读, 不可重复读和幻读`**
    * 脏读: 当前事务A中可以读到其他事务B未提交的数据(脏数据), 这种现象是脏读
    * 不可重复读: 在事务A中先后两次读取同一个数据, 两次读取的结果不一样, 这种现象称为不可重复读
    * 脏读与不可重复读的区别在于: 前者读到的是其他事务未提交的数据, 后者读到的是其他事务已提交的数据
    * 幻读: 在事务A中按照某个条件先后两次查询数据库, 两次查询结果的条数不同, 这种现象称为幻读
    * 不可重复读与幻读的区别在于前者读取的数据变化了,而后者读取的数据行数变化了

    ## **`事务隔离级别`**
    * SQL标准中定义了四种隔离级别, 并规定了每种隔离级别下脏读, 不可重复读和幻读是否存在
    * 一般来说, 隔离级别越低, 系统开销越低. 可支持的并发越高, 但是隔离性也越差
    1. 读未提交(Read Uncommitted): 脏读(可能), 不可重复读(可能), 幻读(可能)
    2. 读已提交(Read Committed): 脏读(不可能), 不可重复读(可能), 幻读(可能)
    3. 可重复读(Repeatable Read, RR): 脏读(不可能), 不可重复读(不可能), 幻读(可能)
    4. 可串行(Serializable): 脏读(不可能), 不可重复读(不可能), 幻读(不可能)
    * 在实际应用中, 读未提交在并发时会导致很多问题, 而性能相对于其他隔离级别提高却很有限, 因此使用较少
    * 可串行化强制事务串行, 并发效率低, 只有当对数据一致性要求极高且可以接受没有并发时使用, 因此使用也较少
    * 因此在大多数数据库系统中, 默认的隔离级别是读已提交(如Oracle)或可重复读(MySQL InnoDB)
    * 可通过下面两个指令查看全局隔离级别和本次会话的隔离级别: `select @@global.tx_isolation;`, `select @@tx_isolation;`
    * InnoDB默认的隔离级别是RR. 在SQL标准中, RR是无法避免幻读问题的, 但是InnoDB实现的RR避免了幻读问题

    ## **`MVCC`**
    * RR解决脏读, 不可重复读和幻读等问题, 使用的是MVCC: MVCC全称Multi-Version-Concurrency Control, 即多版本的并发控制协议
    * MVCC特点: 在同一时刻, 不同事务读取到的数据可能是不同的(即多个版本)
    * MVCC最大的优点是读不加锁, 因此读写不冲突, 并发性能好. InnoDB实现MVCC, 多个版本的数据可以共存, 主要是依靠数据的隐藏列(也可以称之为标记位)和undo log. 其中数据的隐藏列包括了该行数据的版本号, 删除时间, 指向undo log的指针等. 当读取数据时, MySQL可以通过隐藏列判断是否需要回滚并找到回滚需要的undo log, 从而实现MVCC

## **`一致性`**
* 一致性是指事务执行结束后, 数据库的完整性约束没有被破坏, 事务执行的前后都是合法的数据状态
* 数据库的完整性约束包括但不限于:
    1. 实体完整性(如行的主键存在且唯一)
    2. 列完整性(如字段的类型, 大小, 长度要符合要求)
    3. 外键约束
    4. 用户自定义完整性(如转账前后, 两个账户余额的和应该不变)
* 一致性如何实现
    * 可以说, 一致性是事务追求的最终目标. 前面提到的原子性, 持久性和隔离性, 都是为了保证数据库状态的一致性. 除了数据库层面的保障, 一致性的实现也需要应用层面进行保障

    ## **`一致性的实现措施`**
    1. 保证原子性, 持久性和隔离性, 如果这些特性无法保证, 事务的一致性也无法保证
    2. 数据库本身提供保障, 例如不允许向整型列差人字符串值, 字符串长度不能超过列的限制等
    3. 应用层面进行保障, 例如转账操作只扣除转账者的余额, 而没有增加接收者的余额, 无论数据库实现的多么完美, 也无法保证状态的一致

## **`总结`**
* 总结ACID特性及其实现原理
1. 原子性: 语句要么全执行, 要么全不执行. 是事务最核心的特性. 事务本身就是以原子性来定义的, 实现主要基于undo log
2. 持久性: 保证事务提交后不会因为宕机等原因导致数据丢失, 实现主要基于redo log
3. 隔离性: 保证事务执行尽可能不受其他事务影响. InnoDB默认的隔离级别是RR, RR的实现主要基于锁机制, 数据的隐藏列,  undo log和类next-key lock机制
4. 一致性: 事务追求的最终目标, 一致性的实现既需要数据库层面的保障, 也需要应用层面的保障