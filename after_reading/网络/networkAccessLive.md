内容大纲
• TCP/IP协议栈层次与三次握手、四次挥手需要知道的细节
• TCP与UDP适用场景
• linux网络模型
• epoll_event结构中epoll_data_t的fd与ptr使用场景
• Windows网络模型
• 异步connect
• select可以检测网络异常吗
• epoll的水平模式和边缘模式
• 阻塞与非阻塞socket的设置与区别
• send/recv返回值问题
• 如何编写正确的收与发数据代码
• 收发缓冲区如何设计
• SO_SNDTIMEO、SO_RCVTIMEO、TCP_NODELAY、SO_REUSEADDR和SO_REUSEPORT、SO_LINGER选项
• shutdown与优雅关闭
• 错误码EINTR
• tcp粘包问题
• 信号SIGPIPE与EPIPE错误码
• gethostbyname阻塞与错误码
• SO_KEEPALIVE选项与心跳包设计技巧
• 如何设计断线重连机制
• 如何清除无效的死链
• 网络框架中定时器不同实现
• http协议格式、head、get与post方法细节
• http、socks4与socks5代理编码实现

正片: 04:20

体系结构各层的功能(https://blog.csdn.net/qq_45795744/article/details/123571936)
1.tcp协议栈层次 04:30
7层
应用层
表示层
会话层
传输层
网络层
数据链路层
物理层

实际只实现了5层

应用层
tcp层 - 传输层
ip层 - 网络层
数据链路层
物理层


3次握手 4次挥手

https://blog.csdn.net/qq_38950316/article/details/81087809

connet如何实现 - 实际是问TCP/IP三次握手过程
1.首先是客户端向服务器发送SYN同步请求，此时客户端进入SYN_SEND状态,等待服务器确认
2.服务器回答SYN + ACK请求，此时服务器进入SYN_RECV状态
3.客户端再发ACK请求，客户端和服务器进入ESTABLISHED状态,完成三次握手

4次挥手
TCP客户端发送一个FIN，用来关闭客户到服务器的数据传送。
服务器收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。
服务器关闭客户端的连接，发送一个FIN给客户端。
客户端发回ACK报文确认，并将确认序号设置为收到序号加1。

如果三次握手过程中有一处未成功，会从头开始三次握手

在setsockopt中设置SO_REUSEADDR | SO_REUSEPORT，来保证端口或地址可以重用。这样每次调试就不用等待最大生成周期

MSL = 最大生成周期(2分钟 - 6分钟不等)
MSL是指四次挥手最后一次发数据给对端，为了保证对端能收到并应答我，就需要等待一段时间，这样才知道数据是否发送成功。如果没有发成功，会等待
一个MSL，如果这段MSL时间内没有应答我，会重发

tcp是可靠的，udp也是可以做到可靠
为什么tcp是可靠的 - 协议栈保证可靠
1.因为tcp有重发机制，比如A机器向B机器发送数据，在一定时间内，B如果没有回复，则会再发
2.tcp发送的数据是有序的，比如A机器发了a b c数据包到B机器，B可能收到的顺序是c b a，则tcp会主动根据每个包的序号重新排列再发给B机器的应用层
3.tcp必须建立在有链接的基础上,tcp的两端机器必须先用connet函数建立具体链接，然后才能调用send或者recv进行收发数据
  但是upd不需要建立链接，直接调用sendto或者recvfrom函数在里面指定ip地址以及端口号即可

tcp有协议栈保证数据是有序的,能保证数据的完整性
udp是需要开发人员来保证数据完整性 - 直播会用到udp，比如服务器向客户端发了好几万帧的数据，就算丢失了几百帧也不会影响视频效果，只需要保证直播的实时响应即可


select!!! poll epoll
在性能要求不高的场景下，用select可以替代epoll.select是轮询一组socket,看哪个socket上可读可写
如果网络出错，select会检测到吗 - 不能，比如select轮询到一个socket有数据，但是这时候链接已经断开，因为socket可读，这时候调用
read函数读数据， 会读到数据为0

阻塞型socket
对于send或者read发不出数据或者读不到数据，会一直阻塞
非阻塞型socket
对于send或者read发不出数据或者读不到数据，会返回-1

如果send或者read返回0说明对端已经关闭了链接，此时可选择关闭链接
如果send或者read返回大于0，说明数据读写成功，返回的值是字节数

如果send返回100个字节，代表100个字节是发到对端了吗？ - 不是的，send只是把数据放在了tcp协议栈，具体什么时候发送数据，是操作系统的行为

操作系统具体什么时候发数据呢？
默认行为，操作系统会选择累积数据包到一定数量，然后再发送到对端，这是为了减少网络通信次数 - socket的TCP_DELAY参数
使用TCP_NODELAY选项，操作系统直接发送数据包而不会累积

异步connet
当socket阻塞模式时，用connet连接的时候是会阻塞的
如果不希望阻塞该怎么办？ - 将socket设置成非阻塞,然后用connet连接，判断返回值，非阻塞模式下不管连接成功还是不成功都会立刻有返回值
如果返回值是0表示连接成功
如果返回值是-1，并不表示出错，如果不是EWouldBlock才表示出错
这时设置select一个timeout，如果在timeout时间内检测到socket是可写的，表明已经连接成功

epoll - 最高效网络模型
select和poll本质上还是在轮询一组socket
epoll不需要应用程序轮询socket，而是利用操作系统来进行监听.有事件的话，会返回句柄

epoll的水平触发Level Trigger和边缘触发Egde Trigger区别
主要体现在收数据方面, 水平触发表示只要socket上有信号它就会触发,边缘模式表示socket上有事件改变就会触发
水平触发在每次接受到数据都会触发，边缘模式在连续收到数据A, 数据B, 必须等到读完数据A才会触发，否则不会读数据B

1. 水平触发和边缘触发只在读数据上有意义，在写数据上没有意义
发数据会直接调用send或者write去发

怎么将socket设置成非阻塞的 http://blog.csdn.net/analogous_love/article/details/53033102
linux
在创建socket的时候可以把type参数设置成非阻塞SOCK_NONBLOCK 也可以用accept4 将最后一个参数设置成SOCK_NONBLOCK
Windows
创建socket的时候不能设置成非阻塞，但是可以调用windows的api将socket设置成非阻塞


优雅关闭
1.shutdown函数
2.SO_LINGER参数

3.KEEP_ALIVE参数 
防火墙会关闭长期没有数据通信的链接，此时可以用心跳包协议或者用KEEP_ALIVE参数
如果用了KEEP_ALIVE参数，所有socket都会自动发送心跳包来维持链接(不管有没有数据)，这会浪费网络流量，而且默认情况是2个小时发一次心跳包
建议是开发设计应用层的心跳包协议支持长连接


为什么经常需要把SIGPIPE屏蔽?
当一个链接已经关闭了，这时候我们调用send或者read会返回0,表示对端已经关闭。如果这时候程序没设计好，再次调用read或者send就会产生
SIGPIPE或者EPIPE信号。相当于链接关闭时再次调用send或者read，操作系统就会产生这个信号
这时候如果不处理这个信号，程序会直接崩溃

getHostByName
将域名转换成ip地址
这个函数有个使用陷阱 - 默认是阻塞的

为什么服务器端需要定时器
因为服务器会产生很多死链
什么时候会产生死链 - 有两种情况
1.四次挥手的时候，由于另外一端意外崩溃或关闭，或突然关机产生timewait,closewait，这时候就需要清理，否则会一直占用服务器资源
2.端与端之间链接线路的故障，比如服务器S与客户端C中间有链路X Y Z,如果X Y出现了故障中断，S和C的网络函数是无法检测到的
  这时候就得通过心跳包来检测端与端的连接。心跳包的使用需要使用到定时器

 tcp如何解决粘包或者丢包问题
 关于丢包，因为tcp是可靠的，所以不存在丢包
 关于粘包，通常TCP会根据优化算法把这些数据合成一包后一次发送出去，这样接收方就收到了粘包数据
 解决粘包 - 组织完整的包，数据包的设计格式
 1.规定协议都是固定大小，比如规定每10个字节都是一个包
 2.数据包以某个特殊字符来作为结束标记
 3.用的最多是在包头中指定包体长度来收包，包头的大小是固定的.包头中有一个字段是指定包体大小，然后去收固定大小包体的数据

 断线重连机制是如何设计
 两种情况
 1.客户端发现连接断开，然后主动重连
 2.分布式服务或者一组服务中的下游服务去连接上游服务
 什么时候重连？
 1.断开后，每隔一段时间申请重连 - 可行，不推荐
 2.在检测到操作系统网络变化的时候重连
 3.提供对话框或按钮，让用户主动进行重连


 http协议
 http协议是应用层协议，也就是说http协议是建立在tcp/ip基础上的协议
 http协议也是有包头包体，与html的head和body无关。html里面的head和body都是http协议应答数据的包体部分
 http协议的包头是一行一行的，每一行都是以"\r\n"结束，当包头结束，会以单独的"\r\n"结束，也就是包头结束后有两个"\r\n"

 head,get和post部分
 head请求只是请求协议头部分
 get请求 如果有参数，用问号并用&来请求，get的请求是附加到网址后面的，因为网址长度有限制，所以get请求有长度限制
 post请求 参数是放在http协议包体里面
 以上是get和post的核心区别
 协议头有content-length字段，就是指定post请求的包体长度

 connetion == keep-alive
 使用该字段只是建议服务器保持长连接，但是不代表服务器一定会遵守，这不是硬性保证

 代理功能
 比如A连接B，通过代理C，就变成A连接C再连接B


#########################
redis源码