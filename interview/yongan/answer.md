## **`TCP协议是如何保证数据可靠有序的(http://zhuanlan.zhihu.com/p/112317245, https://zhuanlan.zhihu.com/p/136522146)`**
* 确认应答与序列号 / 超时重传
    ## **`确认应答与序列号`**
    * 序列号: TCP传输时将每个字节的数据都进行了编号, 这就是序列号
    * 确认应答: TCP传输过程中, 每当接收方收到数据后, 都会对传输方进行应答, 也就是发送ACK报文. 这个ACK报文带有对应的确认序列号, 告诉发送方接收到了哪些数据, 下一次的数据从哪里发送
    * 序列号的作用不仅仅是应答作用, 有了序列号就能根据序列号对数据进行排序, 并且去掉重复的序列号数据
    ## **`超时重传`**
    * 有两种可能会触发超时重传. 1. 数据发送方发送过程中由于网络原因导致数据丢包, 接收方根本没收到数据. 2. 数据接收方收到了数据, 但是发送ACK响应报文时由于网络故障, 发送失败
    * 为了解决丢包导致的应答失败, TCP引入了超时重传机制. 即就是在发送方发送数据后一段时间内, 若没有收到接收方的ACK响应, 那么刚刚发送的数据会重新发送.
    * 对于原因1: 数据会重新发送, 等待接收方回应ACK
    * 对于原因2: 接收方再次收到同样的数据后根据序列号判断是否是重复数据, 如果是则丢弃, 返回ACK响应
* 拥塞控制
* 检验和

## **`上下文管理器是什么, 怎么实现(https://zhuanlan.zhihu.com/p/26487659)`**
* 实现__enter__, __exit__方法 / 使用contextmanager装饰器
    ## **`实现__enter__, __exit__方法`**
    * 任何实现了__enter__(), __exit__()方法的对象都可称为上下文管理器, 上下文管理器对象可以使用with关键字
    * __enter__()方法返回资源对象, __exit__()处理一些清除工作
    ## **`使用contextmanager装饰器`**
    * python还提供contextmanager, 更进一步简化了上下文管理器的实现方式
    * 通过yield将函数分割成两部分, yield之前的部分在__enter__中执行, yield之后的部分在__exit__中执行, 紧跟在yield之后是资源对象

## **`进程, 线程, 协程的区别(https://zhuanlan.zhihu.com/p/166536738)`**
* 进程是资源分配和调度的独立单元, 进程拥有完整的虚拟地址空间, 当发生进程切换时, 不同的进程拥有不同的虚拟地址空间. 而同一进程的多个线程共享同一地址空间, 而不同进程之间的线程无法共享
* 线程是CPU调度的基本单元, 一个进程包含若干线程(至少一个线程)
* 线程比进程小, 基本上不拥有系统资源. 线程的创建和销毁所需的时间比进程小得多
* 由于线程之间能够共享地址空间, 所以需要考虑同步和互斥的问题
* 一个线程的意外终止会影响整个进程的正常运行, 但一个进程的意外终止不会影响其他进程的运行. 因此多进程程序安全性更高

* 协程是一种比线程更轻量级的存在, 协程不是被操作系统内核所管理, 而完全由程序所控制
* 协程可以比作子程序, 但执行过程中子程序内部可以中断, 转而执行别的子程序. 在适当的时候再返回继续执行, 协程之间的切换不需要设计任何系统调用或任何阻塞调用
* 协程只在一个线程中执行, 是子程序的切换, 发生在用户态. 因此协程相比线程节省了线程创建和切换的开销
* 协程中不存在同时写变量的冲突, 因此不需要添加守卫关键区块的同步性原语, 比如互斥锁, 信号量等