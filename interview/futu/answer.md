### [python垃圾回收](https://zhuanlan.zhihu.com/p/31150408?utm_source=wechat_session&utm_medium=social&utm_oi=659513342490841088)
## **`垃圾回收策略`**
* 引用计数为主, 标记清除和分代回收为辅
## **`回收系统工作内容`**
* 为新生成的对象分配内存, 识别垃圾对象(垃圾检测), 清除垃圾对象(回收内存)
## **`策略详解`**
* 引用计数 / 标记清除+分代回收 / 循环引用
    ## **`引用计数`**
    * 每个对象都有个计数值ob_refcnt, 当一个对象有新的引用时ob_refcnt + 1, 当引用的对象被删除ob_refcnt - 1
    * 当ob_refcnt为0时, 该对象生命结束, 释放内存
    * 优点: 该策略简单, 只需维护计数即可. 而且有实时性, 一旦没有引用, 内存就释放. 内存回收的时间分摊到了平时. 不用等到特定时间, 统一处理
    * 缺点: 维护引用计数消耗资源(对于现在的硬件资源, 该缺点可忽略). 引用计数不能解决循环引用, 所以需要引入标记清除 + 分代回收
    ## **`标记清除 + 分代回收(https://zhuanlan.zhihu.com/p/83251959)`**
    * 只有容器对象才可能产生循环引用的情况, 如列表, 字典, 用户自定义类对象, 元祖等. 而像数字, 字符串这类简单的类型不会出现循环引用.特别的, 对于只包含简单类型的元祖也不在标记清除算法的考虑之列
    * 标记阶段: 遍历当前的所有对象, 如果是可达的也就是还有对象去引用它, 那么就将其标记为可达
    * 清除阶段: 再次遍历对象, 如果发现某个对象没有标记为可达, 则回收其内存
    * 标记清除阶段会阻塞整个应用程序, 等待回收结束才恢复运行
    * 为了减少标记清除阻塞应用程序的时间, python引入了分代回收算法, 以空间换时间的方法提高垃圾回收效率
    * 对象存在的时间越长就越不可能是是垃圾, 应当越少去收集. 新对象的生命周期往往比较短, 老对象的生命周期反而更长
    * python使用三代(即三个链表)去管理垃圾回收, 使用gc.get_threshold()可参看三代的回收门槛(700, 10, 10)
    ## **`循环引用`**
    * 两个对象互相引用, ob1 = list(), ob2 = list(), ob1.append(ob2), ob2.append(ob1)
    * 此时无法通过引用计数来回收内存, 必须使用标记清除算法来释放内存
## **`编程应用`**
* sys.getrefcount(obj) 返回被引用次数, 该函数会使得实际调用值 + 1
* gc.collect() 返回此次回收的不可达对象个数
* gc.get_threshold() 返回各代的回收阈值
* gc.set_threshold(t0, t1, t2) 设置各代阈值, 特别的gc.set_threshold(0)为禁用gc
* gc.garbage 返回不可达且无法被回收的对象列表
* gc.get_referents(*obj) 返回obj指向的对象
* gc.get_referrers(*obj) 返回所有指向obj的对象
## **`触发机制`**
* 达到垃圾回收阈值, python自动回收
* 手动执行gc.collect()
* python虚拟机退出时