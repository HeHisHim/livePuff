### [python垃圾回收](https://zhuanlan.zhihu.com/p/31150408?utm_source=wechat_session&utm_medium=social&utm_oi=659513342490841088)
## **`垃圾回收策略`**
* 引用计数为主, 标记清除和分代回收为辅
## **`回收系统工作内容`**
* 为新生成的对象分配内存, 识别垃圾对象(垃圾检测), 清除垃圾对象(回收内存)
## **`策略详解`**
* 引用计数 / 标记清除+分代回收 / 循环引用
    ## **`引用计数`**
    * 每个对象都有个计数值ob_refcnt, 当一个对象有新的引用时ob_refcnt + 1, 当引用的对象被删除ob_refcnt - 1
    * 当ob_refcnt为0时, 该对象生命结束, 释放内存
    * 优点: 该策略简单, 只需维护计数即可. 而且有实时性, 一旦没有引用, 内存就释放. 内存回收的时间分摊到了平时. 不用等到特定时间, 统一处理
    * 缺点: 维护引用计数消耗资源(对于现在的硬件资源, 该缺点可忽略). 引用计数不能解决循环引用, 所以需要引入标记清除 + 分代回收
    ## **`标记清除 + 分代回收`**
    * 初始化所有对象为白色, 确定根结点为黑色(多指全局引用和函数栈上的引用, 不会被删除), 有效对象引用的对象为灰色表示可达
    * 检测完灰色对象引用的对象后, 将灰色标记为黑色. 重复上述步骤直到不再存在灰色对象, 遗留的白色结点都是需要清除的对象
    * 对象存在的时间越长就越不可能是是垃圾, 应当越少去收集. 新对象的生命周期往往比较短, 老对象的生命周期反而更长
    * python使用三代(即三个链表)去管理垃圾回收, 使用gc.get_threshold()可参看三代的回收门槛(700, 10, 10)
## **`编程应用`**
## **`循环引用如何处理`**
## **`使用建议`**
## **`触发机制`**