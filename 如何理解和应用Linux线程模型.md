### 内容大纲

## **`线程基础`**
### 线程概念
线程是操作系统能够调度和执行的一个基本单位, 在linux中也被称之为轻量级进程, 在不同的操作系统中(windows和linux)实现的方式不一定一样
### Linux线程实现方式
1. 在linux内核里面, 其实是没有线程的概念的, 它把线程当成一个标准的进程来实现. 也就是说, 在linux内核里面, 它没有为线程提供任何的特殊处理和调度语句, 也没有为线程实现特定的数据结构. 但是linux为进程实现了一个struct数据结构
2. 线程对于linux来说, 它是进程间共享资源的一种方式, 所以也称linux的线程是轻量级的进程

## **`Linux Thread vs Process`**
### 资源共享层面的差异
1. 线程共享了某一个进程的资源, 这些资源包括内存的地址空间, 实体内存和虚拟内存, 进程的基础信息(pid, 资源限制等), 堆里面的数据文件, 打开的文件列表, 进程的信号处理, 工作目录, 用户组及数据等
2. 线程专用数据: 线程id, 寄存器数据, 线程栈的局部变量和返回地址, 错误码errno, 信号掩码和优先级等
### 调度层面的差异
* 进程上下文切换(也称为: 进程调度或者任务切换), 意为把cpu从一个进程/线程切换到另一个进程/线程来执行
* 线程上下文切换会比进程的上下文切换要快, 因为本质上线程很多资源都是共享进程的, 所以切换的时候需要保存的项是很少的
* 线程进行上下文切换时, 它的虚拟地址空间是不会改变的, 因为线程共享了进程的内存地址空间. 但是进程进行上下文切换的时候, 都需要重新映射虚拟地址空间, 包括切换linux内核态以及寄存器数据的切换, 这些都是比较大的开销.
* 进程切换的时候会干扰处理器的缓存机制, 比如CPU的TLB(转换检测缓冲区). 虚拟机开始的时候需要重新开启一部分缓存
### 性能层面的差异
* 由于线程比较轻量, 很多资源都是共享自进程, 所以在创建或者切换的过程中性能都要远远高于进程
### Thread 缺点 && 应用场景
* 线程最大的缺点是缺乏保护机制, 由于线程间共享内存区域, 所有说全局变量在线程间都是共享的, 所以在多进程访问下要进行同步操作
* 有些语言的库函数是非线程安全的, 需要注意
* 线程的健壮性不强, 当某个线程崩溃时, 整个程序也会随着崩溃

## **`Linux Thread 使用`**
### 创建线程
* `# include<sched.h> int clone(int (*fn)(void *), void* child_stack, int flags, void* arg, ...)`
* 这个函数创建出来的
### 内核线程
### 同步操作

## **`常见的多线程编程模式`**
### leader-follow 模型（主从）
### producer-consumer模型（生产者消费者）
### 高并发索引模型

## **`踩过的坑`**
### 同步问题
### 过载保护
### 公平调度
### Core问题
