### 知乎Live -- 如何理解和应用Linux线程模型
### 主讲人: lecury

### 内容大纲

## **`线程基础`**
### 线程概念
线程是操作系统能够调度和执行的一个基本单位, 在linux中也被称之为轻量级进程, 在不同的操作系统中(windows和linux)实现的方式不一定一样
### Linux线程实现方式
1. 在linux内核里面, 其实是没有线程的概念的, 它把线程当成一个标准的进程来实现. 也就是说, 在linux内核里面, 它没有为线程提供任何的特殊处理和调度语句, 也没有为线程实现特定的数据结构. 但是linux为进程实现了一个struct数据结构
2. 线程对于linux来说, 它是进程间共享资源的一种方式, 所以也称linux的线程是轻量级的进程

## **`Linux Thread vs Process`**
### 资源共享层面的差异
1. 线程共享了某一个进程的资源, 这些资源包括内存的地址空间, 实体内存和虚拟内存, 进程的基础信息(pid, 资源限制等), 堆里面的数据文件, 打开的文件列表, 进程的信号处理, 工作目录, 用户组及数据等
2. 线程专用数据: 线程id, 寄存器数据, 线程栈的局部变量和返回地址, 错误码errno, 信号掩码和优先级等
### 调度层面的差异
* 进程上下文切换(也称为: 进程调度或者任务切换), 意为把cpu从一个进程/线程切换到另一个进程/线程来执行
* 线程上下文切换会比进程的上下文切换要快, 因为本质上线程很多资源都是共享进程的, 所以切换的时候需要保存的项是很少的
* 线程进行上下文切换时, 它的虚拟地址空间是不会改变的, 因为线程共享了进程的内存地址空间. 但是进程进行上下文切换的时候, 都需要重新映射虚拟地址空间, 包括切换linux内核态以及寄存器数据的切换, 这些都是比较大的开销.
* 进程切换的时候会干扰处理器的缓存机制, 比如CPU的TLB(转换检测缓冲区). 虚拟机开始的时候需要重新开启一部分缓存
### 性能层面的差异
* 由于线程比较轻量, 很多资源都是共享自进程, 所以在创建或者切换的过程中性能都要远远高于进程
### Thread 缺点 && 应用场景
* 线程最大的缺点是缺乏保护机制, 由于线程间共享内存区域, 所有说全局变量在线程间都是共享的, 所以在多进程访问下要进行同步操作
* 有些语言的库函数是非线程安全的, 需要注意
* 线程的健壮性不强, 当某个线程崩溃时, 整个程序也会随着崩溃

## **`Linux Thread 使用`**
### 创建线程
* `# include<sched.h> int clone(int (*fn)(void *), void* child_stack, int flags, void* arg, ...)`
* 这个函数创建出来的进程, 它的文件系统资源, 内存地址, 打开的文件描述符还有信号处理其实都是共享父进程的, 换句话说这个用clone创建的进程也叫做linux下的线程
### 内核线程
* 内核会创建一些内核线程来执行一些后台任务. 它相对普通线程来说, 内核线程只能存在于内核空间，是没有自己的地址空间的
* 内核只存在于内核态, 即使上下文切换也不会切换到用户态
* 关于内核态, 操作系统在执行一些关键操作(访问网卡, 实现调度页面)的时候会陷入内核态才能进行. 本质上是一种保护机制
### 同步操作
* 由于在线程间共享了很多资源, 所以在多线程的编程环境下. 为了保障结果的准确性和一致性, 需要对一些共享的资源进行同步
* 如果多线程在访问共享资源时没有同步, 很有可能出现结果的不一致性
* 常见的同步机制称为加锁, 即访问共享资源的时候要有顺序性. 在linux中, 锁的种类有4种
* 使用锁的代价是比较高昂的, 在实现高并发时, 应该避免锁的使用, 或者减少锁的区间
* [锁的种类](http://blog.lecury.cn/2016/02/21/同步互斥(锁).html?utm_source=wechat_session&utm_medium=social&utm_oi=659513342490841088)

## **`常见的多线程编程模式`**
### leader-follow 模型（主从）
* 模型特点: 每个线程与连接对应, 相当于并发数等于线程数. 每个线程都需要经过连接, 处理, 关闭整个过程
* 适用场景: 适用于连接数少, 每次连接处理时间都比较长或cpu密集型的服务
### producer-consumer模型（生产者消费者）
* 模型特点: 主线程用于接收请求, 然后把请求连接套接字放在消费队列中, 然后由epoll进行处理工作. 并提前创建好workThread(工作线程)去竞争这些消费队列中的连接请求
* 适用场景: 适用于连接数多, 每个连接处理时间短的业务
### 高并发索引模型
* 模型特点: 可以实现高并发并且无锁, 即多线程进行访问的时候可以不用加锁. 具体是将事务或请求映射到具体的线程进行处理, 这样线程间就不会发生资源间竞争

## **`踩过的坑`**
### 同步问题
* 优先推荐使用线程变量即thread来修饰数据成员
### 过载保护
* 多线程场景下在处理业务的时候, 常常用到队列, 多个工作线程从队列里面取出任务, 然后进行并发处理. 如果对于任务有时效性的要求, 就需要关注过载保护
* 当任务量过大或者线程来不及处理时, 就需要及时丢弃队列里的任务. 这样才能保证高吞吐, 低延迟. 还需要把在队列里待太久的数据及时丢弃掉
### 公平调度
* 当一个线程负载过高, 多个线程抢占同一把锁但有的线程会出现抢锁频率过低的情况, 都涉及到公平调度
### Core问题
* 当一个线程退出并释放内存的同时, 有别的线程在访问这块内存, 就会出现段错误导致程序崩溃. 这时候需要关注线程的优雅退出以及析构的顺序是正确的
* 多线程在访问STL的时候也可能导致出Core, 因为STL不是线程安全的
